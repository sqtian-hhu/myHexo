---
title: '''JavaBasics3'''
date: 2020-03-11 17:29:29
tags: Java基础
categories: Java
---
## 继承性
继承主要解决的问题就是共性抽取
<!--more-->

如果成员变量父子重名，则创建子对象时，有两种访问方式
1. 直接通过子类对象访问，等号左边是谁，就优先用谁
Person p = new Student();  =>用左边父类Person的成员变量

2. 间接通过成员方法访问，方法属于谁就用谁

三个重名变量：
直接写：就近
this：本类
super：父类

如果成员方法父子重名，创建的是什么类对象，优先用其成员方法，没有则向上找，不会向下寻找


//继承方法中的覆盖重写：override
1. 在继承关系中，方法名称一样，参数列表一样
@override 写在方法前，注解，检测重写是否有效

2. 子类方法的返回值必须小于等于父类方法的返回值范围
Object是所有类的父类

3. 子类方法的权限必须大于等于父类方法的权限修饰符
public > protected > 留空 > private
设计原则：对于已经投入使用的类尽量不要进行修改，定义一个新类继承

子类构造方法：
1. 子类构造方法当中有一个默认隐含的super() 调用父类构造方法
2. 可以通过super关键字调用父类的重载方法
3. super的父类构造调用，必须是子类构造方法的第一个语句，不能调用多次super构造

super：访问父类内容 1. 父类成员变量 super.name 2. 父类成员方法 super.methord() 3. 父类构造方法 super()
this: 访问本类内容 1. 本类成员 this.name 2. 本类成员方法 this.methord() 3. 本类改造 this()
this()也必须是第一个，this()与super()不能在一个构造方法中同时使用

继承的三个特点：1. 单继承 2. 可以多级继承 3. 一个父类可以有多个子类


//抽象方法
加上abstract关键字
public abstract void eat();
抽象方法所在的类必须是抽象类
public abstract class Animal{
}  
1. 不能直接创建抽象类对象
2. 必须用一个子类来继承抽象父类
3. 子类必须覆盖重写抽象方法
4. 抽象类可以有构造方法，供子类创造对象时初始化父类成员使用
5. 抽象类不一定有抽象方法，抽象方法一定要在抽象类中

子类override父类抽象方法没有全写，也是抽象类



//接口
就是一种公共的规范标准
多个类的公共规范
是一种引用数据类型，最重要的内容是其中的抽象方法
定义
public interface 接口名称{
	//内容
}
可以包含：
Java7 1. 常量 2. 抽象方法
Java8 3. 默认方法 4. 静态方法
Java9 5. 私有方法
接口中的抽象方法，修饰符是两个固定关键字：public abstract

使用步骤
1. 接口不能直接使用，必须有一个“实现类”来实现接口
public class 实现类名称 implements 接口名称{
}
2. 实现类必须覆盖重写抽象方法
3. 创建实现类的对象

Java8之后可定义默认方法
public default 返回值类型 方法名称(){
}
主要用于接口升级
接口中加默认方法，实现类可以不用改，后面对象直接调用

不能通过接口实现类的对象来调用接口当中的静态方法
正确用法：通过接口名称直接调用接口中的静态方法，
		  接口名称.静态方法(参数)

Java9允许私有方法
	需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题
	但这个共有方法不应该让实现类使用，应该是私有化的
	解决：1. 普通私有方法，解决多个默认方法之间重复代码的问题
		  2. 静态私有方法，解决多个静态方法之间重复代码问题
		  
接口中也可以定义“成员变量”，但必须使用public static final 修饰符
效果上看是接口的常量，一旦赋值，不可修改
public static final interesting NUM_OF_CLASS = 12；
接口常量名称用全大写，下划线连接
接口不能有静态代码块，或者构造方法

2. 一个类可以实现多个接口
public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{

}

3. 如果实现类的多个接口抽象方法重复了，只要发覆盖重写一次
4. 如果实现类没有覆盖重写所有接口当中的抽象方法，那么实现类必须是一个抽象类
5. 如果实现类所实现的多个接口当中，存在重复的默认方法，则必须对多个接口冲突的方法覆盖重写
6. 如果实现类父类的方法与接口的默认方法一样，优先用父类的方法

接口之间是可以多继承的
public interface MyInterface extends MyInterfaceA,MyInterfaceB{
}